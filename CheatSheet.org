#+TITLE: PythonCheatSheet
#+MACRO: blurb Quick reference to a tremendously accessible high-level language ---executable pseudocode!
#+AUTHOR: [[https://alhassy.github.io/][Musa Al-hassy]]
#+EMAIL: alhassy@gmail.com
#+INCLUDE: CheatSheet/CheatSheetSetup.org
#+PROPERTY: header-args :results output
#+TODO: Todo | spacing LaTeX

# src_python[:exports code]{

* COMMENT The type of types is â€˜typeâ€™, which is its own type!
#+begin_src python
# The type of types is â€˜typeâ€™, which is its own type!
assert type(1)    == int
assert type(int)  == type
assert type(type) == type
#+end_src

* LaTeX Extra, Local, Setup  :ignore:

# https://tex.stackexchange.com/questions/343494/minted-red-box-around-greek-characters
#+LATEX_HEADER: \usemintedstyle{xcode}

# Empty by default.
#+LATEX_HEADER: \def\cheatsheeturl{https://github.com/alhassy/PythonCheatSheet}

# The following are the defaults & may be omitted.
#+LATEX_HEADER: \def\cheatsheetcols{2}
#+LATEX_HEADER: \landscapetrue
#+LATEX_HEADER: \def\cheatsheetitemsep{-0.5em}

# Example unicode declarations; see section â€œunicodeâ€ below.
#+LATEX_HEADER: \newunicodechar{ğ‘»}{\ensuremath{T}}
#+LATEX_HEADER: \newunicodechar{âŠ•}{\ensuremath{\oplus}}
#+LATEX_HEADER: \newunicodechar{â‰ˆ}{\ensuremath{\approx}}
#+LATEX_HEADER: \newunicodechar{ğ“}{\ensuremath{\mathit{x}}}
#+LATEX_HEADER: \newunicodechar{ğ“Œ}{\ensuremath{\mathit{w}}}
#+LATEX_HEADER: \newunicodechar{ğ“}{\ensuremath{\mathit{y}}}

#+LATEX_HEADER: \newunicodechar{Î±}{\ensuremath{\alpha}}
#+LATEX_HEADER: \newunicodechar{ğ“ˆ}{\ensuremath{\mathit{s}}}

* Contents :TOC:QUOTE:ignore:
#+BEGIN_QUOTE
- [[#hello-world][Hello, World!]]
  - [[#this-is-how-we-do-it][This is how we do it]]
  - [[#exploring-built-in-modules-with-dir-and-help][Exploring built-in modules with ~dir~ and ~help~]]
- [[#arithmetic][Arithmetic]]
- [[#conditionals][Conditionals]]
  - [[#boolean-connectives][Boolean connectives]]
  - [[#relational-operations][Relational operations]]
  - [[#if-expressions-and-statements][If expressions and statements]]
- [[#iterables][Iterables]]
  - [[#comprehensions][Comprehensions]]
  - [[#generators][Generators]]
  - [[#unpacking-operation][Unpacking operation]]
  - [[#loops][Loops]]
  - [[#forwhile-via-iternext][For/while via iter/next]]
  - [[#methods-on-iterables][Methods on Iterables]]
  - [[#sum-is-monoidal][Sum is monoidal]]
  - [[#methods-for-sequences-only][Methods for sequences only]]
  - [[#sequences-are-ordered][Sequences are Ordered]]
- [[#tuples][Tuples]]
- [[#strings][Strings]]
  - [[#string-comprehensions][String Comprehensions]]
  - [[#string-methods][String methods]]
  - [[#f-strings-formatted-string-literals][f-strings: Formatted String Literals]]
- [[#lists][Lists]]
- [[#sets][Sets]]
- [[#dictionaries][Dictionaries]]
  - [[#dictionaries-implement-hierarchical-tree-structures-and-case-statements][Dictionaries implement hierarchical tree structures and case statements]]
  - [[#dictionary-methods][Dictionary Methods]]
- [[#splicing][Splicing]]
- [[#functions][Functions]]
  - [[#functions-have-attributes][Functions have attributes]]
  - [[#on-the-nature-of-Î»][On the nature of Î»]]
  - [[#default--keyword-argument-values][Default & keyword argument values]]
  - [[#dictionary-arguments][Dictionary arguments]]
  - [[#type-annotations][Type Annotations]]
  - [[#currying][Currying]]
  - [[#decorators][Decorators]]
- [[#object-oriented-programming][Object-Oriented Programming]]
  - [[#person-empty-class][Person: Empty Class]]
  - [[#a-more-complex-person-class][A More Complex ~Person~ Class]]
  - [[#making-people][Making People]]
  - [[#syntax-overloading-dunder-methods][Syntax Overloading: Dunder Methods]]
  - [[#extension-methods][Extension Methods]]
  - [[#inheritance][Inheritance]]
- [[#decorators-and-classes][Decorators and Classes]]
  - [[#curry-decorator][Curry Decorator]]
- [[#named-expressions][Named Expressions]]
- [[#modules][Modules]]
- [[#reads][Reads]]
#+END_QUOTE

* COMMENT single column portrait of the cheat sheet

Press ~C-c C-c~ on the following incantation to produce a single column portrait of the cheat sheet.
#+name: make-portrait
#+BEGIN_SRC emacs-lisp :results none
(with-temp-buffer
    (insert
    "#+EXPORT_FILE_NAME: CheatSheet_Portrait.pdf
     ,#+LATEX_HEADER_EXTRA: \\landscapefalse \\def\\cheatsheetcols{1}
     ,#+INCLUDE: CheatSheet.org
    ")

    (let ((org-export-use-babel nil))
      (org-mode)
      (org-latex-export-to-pdf)
      )
)
#+END_SRC

* COMMENT Emacs Setup

#+begin_src emacs-lisp
(org-babel-do-load-languages
 'org-babel-load-languages
 '((python . t)))

(setq org-babel-python-command "python3")

;; To see the buffer running the interpreter
;; (org-babel-switch-to-session)
#+end_src

#+RESULTS:

#+begin_src shell
# brew install python@3.8
# echo 'export PATH="/usr/local/opt/python@3.8/bin:$PATH"' >> ~/.zshrc

# Reload the environemtn variables from within emacs
# source ~/.zshrc
# (exec-path-from-shell-copy-env "PATH")

python3 --version
#+end_src

#+RESULTS:
: Python 3.8.1

Python has been installed as
  /usr/local/opt/python@3.8/bin/python3

You can install Python packages with
  /usr/local/opt/python@3.8/bin/pip3 install <package>

They will install into the site-package directory
  /usr/local/opt/python@3.8/Frameworks/Python.framework/Versions/3.8/lib/python3.8/site-packages

See: https://docs.brew.sh/Homebrew-and-Python

python@3.8 is keg-only, which means it was not symlinked into /usr/local,
because this is an alternate version of another formula.

If you need to have python@3.8 first in your PATH run:
  echo 'export PATH="/usr/local/opt/python@3.8/bin:$PATH"' >> ~/.zshrc

For compilers to find python@3.8 you may need to set:
  export LDFLAGS="-L/usr/local/opt/python@3.8/lib"

For pkg-config to find python@3.8 you may need to set:
  export PKG_CONFIG_PATH="/usr/local/opt/python@3.8/lib/pkgconfig"

* Initial negative space :ignore:
  #+latex: \vspace{-1em}
* Hello, World!

#+latex: \hspace{-1.3em}
â‡’ Python is [[https://docs.python.org/3/reference/datamodel.html#objects-values-and-types][object oriented]] and dynamically type checked.

â‡’ With [[Syntax Overloading: Dunder Methods][dunder methods]], every /syntactic construct/ extends to user-defined
  datatypes, classes!  ---Including loops, comprehensions, and even function call
  notation!
  # (See final page.)

# â‡’ Python supports simultaneous assignment; e.g., ~x , y = y , x~ swaps ~x~ and ~y~.
# Covered below, via unpacking!

â‡’ Children block fragments are realised by consistent indentation, usually 4
  spaces. No annoying semicolons or braces.

â‡’ ~Ï„(x)~ to try to coerce =x= into a =Ï„= type element, crashes if conversion is not
possible. Usual types: src_python[:exports code]{bool, str, list, tuple, int, float, dict, set}.
Use src_python[:exports code]{type(x)} to get the type of an object =x=.
:Example:
#+begin_src python :results value
x = 1
type(x)            # â‡’ int
isinstance(x, int) # â‡’ True
#+end_src
:End:

# #
â‡’ Identifier names are case sensitive; some unicode such as =â€œÎ±â€= is okay but not ~â€œâ‡’â€~.

â‡’ If ~obj~ is an instance of type ~Ï„~, then we may invoke an instance method ~f~ in
two ways: ~obj.f()~ or ~Ï„.f(obj)~. The latter hints at why src_python[:exports
code]{â€œselfâ€} is the usual name of the first argument to instance methods. The
former ~Ï„.f~ is the name proper.

â‡’ Function and class definitions are the only way to introduce new, local,
  scope.
  # In-particular, â€œwithâ€ and â€œ:=â€ introduce new names.

â‡’ src_python[:exports code]{del x} deletes the object =x=, thereby removing the name =x= from scope.

â‡’ src_python[:exports code]{print(x, end = e)} outputs =x= as a string followed by =e=; =end= is optional and
  defaults to a newline. =print(xâ‚, â€¦, xâ‚™)= prints a tuple without parentheses or
  commas.

# Functions use parentheses for their arguments, otherwise no parentheses.

â‡’ The src_python[:exports code]{NoneType} has only one value,
src_python[:exports code]{None}.  It's used as the return type of functions that
only perform a side-effect, like printing to the screen. Use src_python[:exports
code]{type(None)} to refer to it.

** This is how we do it

Everything here works using Python3.
#+begin_src python
import sys
assert '3.8.1' == sys.version.split(' ')[0]
#+end_src

#+RESULTS:

We'll use ~assert y == f(x)~ to show that the output of ~f(x)~ is ~y~.
+ Assertions are essentially â€œmachine checked commentsâ€.

:SillyExample:
#+BEGIN_SRC python
x , y = 2 , 3
if x == y:
    pass
else:
    print ("hello")
#+END_SRC
:End:

** Exploring [[https://docs.python.org/3/library/][built-in modules]] with ~dir~ and ~help~

#+latex:\vspace{0.5em}

   | *Explore [[https://docs.python.org/3/library/][built-in modules]] with ~dir~ and ~help~ Â * |

#
| ~dir(M)~    | List of string names of all elements in module ~M~ |
| ~help(M.f)~ | Documentation string of function ~f~ in module ~M~   |

#
#+begin_parallel org
#+begin_src python
import re
for member in sorted (dir(re)):
    if "find" in member:
        print (help ("re." + member))
#+end_src
#+latex: \columnbreak
â‡’ Print alphabetically all regular expression utilities that mention ~find~.

#+latex: \vspace{1.5em}
~help~ can be called directly on a name; no need for quotes.
#+end_parallel


# #
#+latex: \vspace{-1.5em}

* Arithmetic

# ~float(x)~ convert a string decimal number into a float value; similarly ~int(x)~.

#+latex: \hspace{-1.4em}
Besides the usual operators =+, *, **, /, //, %, abs=, declare src_python[:exports code]{from math import *} to obtain
=sqrt, loq10, factorial, â€¦= ---use ~dir~ to learn more, as mentioned above.

- Augmented assignments: ~x âŠ•= y â‰¡ x = x âŠ• y~ for any operator ~âŠ•~.
  # such as ~+, //, **, â€¦~.
- Floating point numbers are numbers with a decimal point.
- =**= for exponentiation and ~%~ for the remainder after division.
- =//=, floor division, discards the fractional part, whereas =/= keeps it.
- Numeric addition and /sequence/ catenation are both denoted by ~+~.
  * However: ~1 + 'a' â‡’ error!~.

#+begin_parallel org
  #+begin_src python
# Readability!
# â€˜_â€™ in numeric literals is ignored
assert 1000000 == 1_000_000

assert 1.2  == float("1.2")
assert -1 == int(float('-1.6'))
# float('a')
# â‡’ Crashes: 'a' is not a number
  #+end_src
#+latex: \columnbreak
#+begin_src python
# Scientific notation: ğ“eğ“ â‰ˆ ğ“ * (10 ** ğ“)
assert 250e-2 == 2.5 == 1 + 2 * 3 / 4.0

from math import *   # See below on imports
assert 2 == sqrt(4)
assert -inf < 123 < +inf
#+end_src
#+end_parallel


:SomeLaws:
math.floor(n) â‰ˆ n // 1
math.ceil(n)  â‰ˆ -(-n//1)
:End:

** Negative Space :ignore:
# #
#+latex: \vspace{-1.5em}

* Conditionals

#
#+begin_parallel org
#+latex: \hspace{-1.3em}
Booleans are a subtype (subclass) of integers, consisting of
two values: =True= and =False=.

#+latex: \vspace{1em} \hspace{-1.3em}
Consequently, we freely get [[https://en.wikipedia.org/wiki/Iverson_bracket][Iverson brackets]].

#+latex: \columnbreak
   #+begin_src python
assert True == 1 and False == 0
assert issubclass(bool, int)
#+end_src

#+latex: \vspace{1em}
#+begin_src python
abs(x) â‰ˆ x * (x > 0) - x * (x < 0)
#+end_src
#+end_parallel

#+latex: \vspace{-1em}
| /Every â€œemptyâ€ collection is considered false! Non-empty values are truthy!/ |

- src_python[:exports code]{bool(x)} â‡’ Interpret object =x= as either true or false.
- E.g. 0, =None=, and  empty tuples/lists/strings/dictionaries are falsey.
#
#+begin_parallel org

   #+begin_src python
assert (False
       == bool(0)
       == bool("")
       == bool(None)
       == bool(())
       == bool([])
       == bool({}))
#+end_src

#+RESULTS:

#+latex: \columnbreak

In Boolean contexts:
#+latex: \vspace{1em}
  | â€œx is emptyâ€ | â‰¡ | =not bool(x)= |
  | ~len(e) != 0~  | â‰¡ | ~bool(e)~     |
  | ~bool(e)~      | â‰¡ | ~e~           |
  | ~x != 0~       | â‰¡ | ~x~           |

#+latex: \vspace{0.5em}
User-defined types need to implement dunder methods [[https://docs.python.org/3.8/reference/datamodel.html#object.__bool__][ =__bool__= ]] or [[https://docs.python.org/3.8/reference/datamodel.html#object.__len__][ ~__len__~ ]].

#+end_parallel
#
# -  =x and y â‰ˆ x= for any falsey =x=; i.e., if ~bool(x)~ is false.

#+latex: \vspace{-0.5em}

** Boolean connectives

Usual infix operations src_python[:exports code]{and, or, not} for /control flow/
whereas ~&, |~ are for Booleans only.
- src_python[:exports code]{None or 4 â‰ˆ 4} but ~None | 4~ crashes due to a type error.
# Perform =sâ‚™= only if all =sáµ¢= are not =None= (falsey); e.g.,
| =sâ‚ and â‹¯ and sâ‚™= | â‡’ | Do ~sâ‚™~ only if all ~sáµ¢~ â€œsucceedâ€ |
| ~sâ‚ or â‹¯ or sâ‚™~   | â‡’ | Do ~sâ‚™~ only if all ~sáµ¢~ â€œfailâ€    |
# /are/ ~None~ (falsey) e.g., do =sâ‚™= if all ~sáµ¢~ â€œfailâ€.
- src_python[:exports code]{x = y or z} â‡’ assign ~x~ to be ~y~ if ~y~ is â€œnon-emptyâ€
  otherwise assign it ~z~.

- Precedence: src_python[:exports code]{A and not B or C â‰ˆ (A and (not B)) or C}.

** Relational operations

#  less-than ~<~
Value equality ~==~, discrepancy ~!=~;
*Chained comparisons are conjunctive*; e.g.,
  | ~x < y <= z~ | â‰¡ | ~x < y and y <= z~ |
  | ~p == q == r~ | â‰¡ | ~p == q and q == r~ |

** If expressions and statements

#+begin_parallel org
/If-expressions/ /must/ have an =else= clause, but /if-statements/ need not =else= nor
=elif= clauses; =â€œelse ifâ€= is invalid.

#+latex: \vspace{1em}
Expressions bind more tightly than statements; whence usually no need to
parenthesise if-expressions.

#+latex: \columnbreak
  #+begin_src python
# If-expression
exprâ‚ if condition else exprâ‚‚

# If-statement
if   conditionâ‚: actionâ‚
elif conditionâ‚‚: actionâ‚‚
elif conditionâ‚ƒ: actionâ‚ƒ
else           : default_action
  #+end_src
#+end_parallel

# #
#+latex: \vspace{-1.5em}

** COMMENT Further equivalences :Iverson:
 Provided no báµ¢ is falsy:

   câ‚€ and bâ‚€ or â‹¯ or câ‚™ and bâ‚™
 â‰ˆ bâ‚€ if câ‚€ else â‹¯ else bâ‚™ if câ‚™

 Since tuples can be indexed:
 (a,b)[c] â‰ˆ a if c else b  (Strict!)

 If neither a nor b are falsy:
 a * bool(c) or b â‰ˆ a if c else b

* Iterables

#+latex: \hspace{-1.3em}
An /iterable/ is an object which can return its members one at a time; this
includes the (finite and ordered) /sequence types/ ---lists, strings, tuples---
and non-sequence types ---generators, sets, dictionaries.  An iterable is any
class implementing =__iter__= and =__next__=; an example is shown later.

+ Zero-based indexing, ~x[i]~, applies to sequence types only.
+ We must have src_python[:exports code]{-len(x) < i < len(x)} and
    src_python[:exports code]{xs[-i] â‰ˆ xs[len(x) - i]}.
  # Else an out of bounds error

We shall cover the general iterable interface, then cover lists, strings,
tuples, etc.

** Comprehensions

*Comprehensions* provide a concise way to create iterables; they consist of
brackets @@latex: \newline@@ ---() for generators, [] for lists, {} for sets and
dictionaries--- containing an expression followed by a =for= clause, then zero or
more =for= or =if= clauses.

#+begin_center
src_python[:exports code]{(f(x) for x in xs if p(x))}
#+end_center
#+latex: \vspace{-0.5em}
â‡’ A new iterable obtained by applying ~f~ to the elements of ~xs~ that satisfy ~p~ â‡

 E.g., the following prints a list of distinct pairs.
  #+latex: \vspace{-0.5em}
 #+begin_src python
print ([(x, y) for x in [1,2,3] for y in (3,1,4) if x != y])
 #+end_src

#
#+begin_parallel org
 #+begin_src python
from itertools import count

evens = (2 * x for x in count())

# First 5 even naturals
for _, x in zip(range(5), evens):
    print (x)
 #+end_src
#+latex: \columnbreak

Generators are â€œsequences whose elements are generated when neededâ€; i.e., are
/lazy lists/.

#+latex: \vspace{1em}
If [,] are used in defining =evens=, the program will take forever
to make a list out of the infinitly many even numbers!
#+end_parallel

 :LoopFusion:
 #+begin_src python
m , n = 2 , 4
print([(i, j) for i in range(m) for j in range(n)])
print([(i, j) for k in range(m * n) for (i, j) in [divmod(k, n)]])

xs = ['a', 'z', 'Î²']
ys = ['ğ’¶', 'ğ“']
print([(x, y) for x in xs for y in ys])
print([(xs[i], ys[j]) for k in range(len(xs) * len(ys)) for (i, j) in [divmod(k, len(ys))]])
 #+end_src
:End:

 Comprehensions are known as monadic do-notation in Haskell and Linq syntax in
 C#.
:More:
  # do x â† a; y â† b; return c â‰ˆ (c for x in a for y in b)
  # #
  # We get this notation by defininig __iter__!
  # #
  # Maybe show this on p8 for delimited continuations ;-)
:End:
** Generators
*Generators* are functions which act as a lazy streams of data: Once a ~yield~ is
 encountered, control-flow goes back to the caller and the function's state is
 persisted until another value is required.

#
#+begin_parallel org

 #+begin_src python
# Infinite list of even numbers
def evens():
    i = 0;
    while True:
        yield i
        i += 2
#+end_src
#+latex: \columnbreak
#+begin_src python
xs = evens()
print (next (xs)) # â‡’ 0
print (next (xs)) # â‡’ 2
print (next (xs)) # â‡’ 4

# Print first 5 even numbers
for _, x in zip(range(5),evens()):
    print x
 #+end_src

#+end_parallel

#+latex: \vspace{-1em}
 Notice that =evens= is just ~count(0, 2)~ from the [[https://docs.python.org/2/library/itertools.html#module-itertools][itertools module]].

** Unpacking operation
   #+latex: \vspace{0.5em}
   | *Unpacking operation* |

+ Iterables are â€œunpackedâ€ with =*= and dictionaries are â€œunpackedâ€ with =**=.

+ Unpacking /syntactically/ removes the outermost parenthesis ()/[]/{}.
  # it is known as =,@= in Lisp.

+ E.g., if =f= needs 3 arguments, then =f(*[xâ‚, xâ‚‚, xâ‚ƒ]) â‰ˆ f(xâ‚, xâ‚‚, xâ‚ƒ)=.
  # This is  =apply= in Lisp.

+ E.g., printing a number of rows: ~print(*rows, sep = '\n')~.
  :Example:
 #+begin_src python
rows = ['Hello', 1, ('a', 3)]
print (*rows, sep = '\n')
a = b = 0
print (a, b)
#+end_src
:End:

+ E.g., [[https://www.python.org/dev/peps/pep-0448/][coercing iterable ~it~:]]
  #+begin_center python
#+begin_src python
  set(it) â‰ˆ {*it}, list(it) â‰ˆ [*it], tuple(it) â‰ˆ (*it,)
#+end_src
  #+end_center
  :Example:
  #+begin_src python
  it = range(10)
  print({*it})
   #+end_src
  :End:

[[https://www.python.org/dev/peps/pep-3132/][Iterable unpacking syntax]] may also be used for assignments, where ~*~ yields
lists.

  | ~x, *y, z = it~ | â‰¡ | ~x = it[0]; z = it[-1]; y = list(it[1:len(it)-1])~ |
  |               | â‡’ | ~[x] + ys + [z] = list(it)~                          |

E.g., ~head , *tail = xs~ to split a sequence.

In particular, since tuples only need parenthesis within expressions,
we may write @@latex:\newline@@ ~x , y = eâ‚, eâ‚‚~ thereby obtaining *simultaneous assignment*.
@@latex:\newline@@
E.g., ~x, y = y , x~ to swap two values.
:Example:
#+begin_src python
it = range(10)
x, *y, z = it ; w = 0
print(x, y, z)
#+end_src

#+RESULTS:
: 0 [1, 2, 3, 4, 5, 6, 7, 8] 9

:End:

** Loops

#
#+begin_parallel org
*Loops* let us /iterate over/ iterables!

#+latex: \vspace{1.3em}
 â‡’ =break= exists a loop early; =continue= skips the current loop iteration.

#+latex: \vspace{1.3em}
 â‡’ Loops may be followed by an ~else:~ clause, which is executed /only/ if the loop
   terminated by its condition failing ---not due to a =break=!

#+latex: \columnbreak

 #+begin_src python
# for-loop over a set
for x in {2, 3, 4}: print (x)
else: print ("for-loop is done")

# Looping over characters with indices
for i, x in enumerate('abc'):
    print (f"{i} goes to {x}")

# â€œwhile loopâ€ over a tuple
i, xs = 0, (2, 3, 4)
while i < len(xs):
    print (xs[i])
    i += 1
     #+end_src
#+end_parallel

** For/while via iter/next
Any user-defined class implementing ~__iter__~ and ~__next__~ can use loop syntax.
# and all iterable methods apply.

#+BEGIN_SRC python
  for x in xs: f(x)
â‰ˆ it = iter(xs); while True: try: f(next(it)) except StopIteration: break
#+END_SRC

+ ~iter(x)~ â‡’ Get an iterable for object =x=.
+ ~next(it)~ â‡’ Get the current element and advance the iterable =it= to its next
  state.
  - Raise [[https://docs.python.org/3.6/library/exceptions.html#StopIteration][StopIteration]] exception when there are no more elements.

** Methods on Iterables

 #+latex: \vspace{1em}
| *Methods on Iterables* |

# Here are a few methods that apply to iterables.

+ src_python[:exports code]{len} gives the length of (finite) iterables
  - =len ((1, 2))= â‡’ 2; the extra parentheses make it clear we're giving /one tuple
    argument/, not /two integer arguments/.
  :Examples:
   #+BEGIN_SRC python
assert 2 == len ('hi')
assert 2 == len ((1, 2)) # â‡’ Extra parens to make it clear we're giving ONE tuple argument, not TWO integer arguments.
assert 2 == len ([1, 2])
assert 2 == len ({'h', 'i'})
assert 2 == len ({'h' : 20, 'i': 41})
#+END_SRC
  :End:

+ src_python[:exports code]{x in xs} â‡’ check whether value =x= is a member of =xs=
  - src_python[:exports code]{x in y â‰¡ any(x == e for e in y)}, provided ~y~ is a finite iterable.
  - src_python[:exports code]{x in y â‰¡ y.__contains__(x)}, provided =y='s class defines the method.
  - src_python[:exports code]{x not in y â‰¡ not x in y}
  :Examples:
    #+begin_src python
  assert 'x' in 'xs' and 'x' in {'x', 's'}
  assert not 1 in [2, 3, 4]
  assert 1 not in (2, 3, 4)
    #+end_src
  :End:

+ src_python[:exports code]{range(start, stop, step)} â‡’ An iterator of integers from =start= up to =stop-1=,
  skipping every other =step-1= number.
  - Associated forms: =range(stop)= and =range(start, stop)=.

+ src_python[:exports code]{reversed(xs)} returns a reversed iterator for ~xs~;
  likewise src_python[:exports code]{sorted(xs)}.

+ src_python[:exports code]{enumerate(xs) â‰ˆ zip(xs, range(len(xs)))}
  - Pair elements with their indices.

+ src_python[:exports code]{zip(xsâ‚, â€¦, xsâ‚™)} is the iterator of tuples ~(xâ‚, â€¦, xâ‚™)~ where ~xáµ¢~ is from ~xsáµ¢~.

  - Useful for looping over multiple iterables at the same time.
     # ~for x, y in zip(xs, ys): â‹¯~.
  - src_python[:exports code]{zip(xs, ys) â‰ˆ ((x, y) for x in xs for y in ys)}
  - src_python[:exports code]{xsâ‚ , â€¦, xsâ‚™ = zip(*ğ“ğ“ˆ)} â‡’ â€œunzipâ€ =ğ“ğ“ˆ=, an iterable of tuples, into a tuple of
    (abstract) iterables ~xsáµ¢~, using the unpacking operation =*=.
    :Example:
  # Unzip an iterator to obtain a pair of iterators via ~xs , ys = zip(*zs)~; then use ~list(xs)~ to get a list of ~xs~.
   #+begin_src python
zs = list(zip(['a', 'b'], [1, 2, 3]))
xs , ys = list(zip(*zs))
assert [1, 2] == list(ys)
#+end_src

   E.g., ~list(zip(*[(xâ‚, yâ‚), (xâ‚‚, yâ‚‚)])) â‰ˆ list(zip((xâ‚, yâ‚), (xâ‚‚, yâ‚‚))) â‰ˆ [(xâ‚,
   xâ‚‚), (yâ‚, yâ‚‚)]~, hence we â€œunzipâ€ using =zip(*â‹¯)=.  â‡’ Note we need ~list(â‹¯)~ to
   actually get a list since =zip= just returns an abstract iterator of tuples. â‡
    :End:
   #+begin_src python
xs , Ï„ = [ {1,2} , [3, 4] ] , list
assert Ï„(map(tuple, xs)) == Ï„(zip(*(zip(*xs)))) == [(1,2) , (3,4)]
# I claim the first â€œ==â€ above is true for any xs with:
assert len({len(x) for x in xs}) == 1
   #+end_src

   # I.e., the iterables in xs all have the same length.
   # len({len(x) for x in xs})
   # len(set(map(len, xs))) == 1.

+ src_python[:exports code]{map(f, xsâ‚, â€¦, xâ‚™)} is the iterable of values ~f xâ‚ â€¦ xâ‚™~ where ~xáµ¢~ is from ~xsáµ¢~.
  - This is also known as /zip with f/, since it generalises the built-in
    ~zip~.
    # - It is how Common Lisp mapcar works.
  - src_python[:exports code]{zip(xs, ys) â‰ˆ map(lambda x, y: (x, y), xs, ys)}
  - src_python[:exports code]{map(f, xs) â‰ˆ (f(x) for x in xs)}

+ src_python[:exports code]{filter(p, xs) â‰ˆ (x for x in xs if p(x))}

  #  =filter= takes a predicate and an iterable, it filters out all those elements
  # that fail to satisfy the predicate.

+ src_python[:exports code]{reduce(âŠ•, [xâ‚€, â€¦, xâ‚™], e) â‰ˆ e âŠ• xâ‚€ âŠ• â‹¯ âŠ• eâ‚™}; the
  initial value ~e~ may be omitted if the list is non-empty.

   #+begin_src python
from functools import reduce

assert 'ABC' == reduce(lambda x, y: x + chr(ord(y) - 32), 'abc', '')
#+end_src

  These are all instances of src_python[:exports code]{reduce}:
  - src_python[:exports code]{sum, min/max, any/all} ---remember â€œemptyâ€ values
    are falsey!
        #+begin_src python
# Sum of first 10 evens
assert 90 == (sum(2*i for i in range(10)))
#+end_src
  - Use ~prod~ from the ~numpy~ module for the product of elements in an iterable.

** Sum is monoidal
#+latex: \vspace{1em}
   | *Flattening* |

 Since,
   src_python[:exports code]{sum(xs, e = 0) â‰ˆ e + xs[0] + â‹¯ + xs[len(xs)-1]}
 We can use =sum= as a generic â€œlist of Ï„ â†’ Ï„â€ operation by providing
 a value for =e=. E.g., lists of lists are catenated via:

 #+begin_src python
assert [1, 2, 3, 4] == sum([[1], [2, 3], [4]], [])
assert (1, 2, 3, 4) == sum([(1,), (2, 3), (4,)], ())
# List of numbers where each number is repeated as many times as its value
assert [1, 2, 2, 3, 3, 3, 4, 4, 4, 4] == sum([i * [i] for i in range(5)], [])
 #+end_src

# +latex: \vspace{1em}

** COMMENT New column :ignore:
#+latex: \columnbreak
** Methods for sequences only
#+latex: \columnbreak
# +latex: \vspace{1em}
| *Methods for sequences only* |

# Here are some operations that apply only to /sequence types/.

#+begin_parallel org
Numeric addition and /sequence/ catenation are both denoted by ~+~; however: ~x + y~
crashes when src_python[:exports code]{type(x) != type(y)}.
#+latex: \columnbreak
#+begin_src python
assert 'hi' == 'h' + 'i'
assert (1, 2, 3, 4) == (1, 2) + (3, 4)
assert [1, 2, 3, 4] == [1, 2] + [3, 4]
  #+end_src
#+end_parallel

#+latex: \vspace{-0.7em}
#+begin_parallel org
Multiplication is iterated addition; not just for numbers, but for all /sequence
types/!
#+latex: \columnbreak
#+BEGIN_SRC python
assert "hi" * 2  == 2 * "hi" == "hihi"
assert (1,2) * 3 == (1, 2, 1, 2, 1, 2)
assert [1] * 3   == [1, 1, 1]
#+END_SRC
#+end_parallel

#+latex: \vspace{-0.7em}
#+begin_parallel org
=xs.index(ys)= returns the first index in =xs= where =ys= occurs, or a src_python[:exports code]{ValueError} if
it's not present.
#+latex: \columnbreak
#+BEGIN_SRC python
assert 1 == "abc".index('bc')
assert 0 == (1, 2, 3).index(1)
assert 1 == ['h', 'i'].index('i')
#+END_SRC
#+end_parallel

#+latex: \vspace{-0.7em}
#+begin_parallel org
=xs.count(ys)= returns the number of times =ys= occurs as an element/substring of =xs=.
#+latex: \columnbreak
#+BEGIN_SRC python
assert 1 == "abc".count('ab')
assert 0 == [1, 2, 3].count('ab')
assert 1 == [1, 2, 3].count(2)
assert 0 == [1, 2, 3].count([2, 3])
assert 1 == [1, [2, 3]].count([2, 3])
#+END_SRC
#+end_parallel
#+latex: \vspace{-0.5em}

** Sequences are Ordered
#+latex: \vspace{0.3em}
| *Sequences are Ordered* |

#+latex: \vspace{-0.3em}
Sequences of the same type are compared lexicographically: Where ~k = min(n, m)~,
@@latex:\newline@@ ~[xâ‚€, â€¦, xâ‚™] < [yâ‚€, â€¦, yâ‚˜] â‰¡ xâ‚€ < yâ‚€ or â‹¯ or xâ‚– < yâ‚–~
---recalling that Python's ~or~ is lazy; i.e., later arguments are checked only if
earlier arguments fail to be true. Equality is component-wise.
#+latex: \vspace{-0.5em}
#+begin_src python
assert [2, {}] != [3] # â‡’ Different lengths!
assert [2, {}] < [3]  # â‡’ True since 2 < 3.
assert (1, 'b', [2, {}]) < (1, 'b', [3])
#+end_src

** Negative space :ignore:
# #
#+latex: \vspace{-1em}

* Tuples

#+latex: \hspace{-1.3em}
  A /tuple/ consists of a number of values separated by commas ---parenthesis are
  only required when the tuples appear in complex expressions.

#
#+begin_parallel org
  Tuples are immutable; no setters.

  #+latex: \vspace{2em}
  But we can access then alter /mutable components/ of a tuple;
  e.g., we can alter the list component of =t= â‡’

  #+latex: \vspace{1em}
  Getter is usual indexing, ~xs[i]~.

  #+latex: \vspace{3em}
  Convert ~x~ to a tuple with ~tuple(x)~.

  #+latex: \vspace{2.5em}
Iverson brackets again!
# Since tuples can be indexed:

#+latex: \columnbreak
  #+begin_src python
# Heterogeneous tuples
t = 1, 'b', [3], (4, 5)

# Alter mutable component
t[2][0] = 33
assert t == (1, 'b', [33], (4, 5))

empty_tuple = ()          # â‡’ ()
singleton_tuple = 'one',  # â‡’ ('one',)
# Note the trailing comma!

assert (('3', '4') == tuple(['3', '4'])
                   == tuple('34'))

(a, b)[c] â‰ˆ a if c else b  # Eager!
  #+end_src
#+end_parallel

#+latex: \vspace{-1.5em}
Simultaneous assignment is really just tuple unpacking on the left and tuple
packing on the right.

** Negative space                                                    :ignore:
 # #
 #+latex: \vspace{-1em}

* Strings

#+latex: \hspace{-1.3em}
Strings are both ~"~-enclosed and ='=-enclosed literals; the former easily allows us
to include apostrophes, but otherwise they are the same.

+ There is no separate character type; a character is simply a string of size
  one.
  - src_python[:exports code]{assert 'hello' == 'he' + 'l' + 'lo' == 'he' 'l' 'lo'}
  - String literals separated by a space are automatically catenated.

   :Hide:
   #+begin_src python
assert 'hello' == 'he' + 'l' + 'lo' == 'he' 'l' 'lo'
#+end_src
   :End:

+ String characters can be accessed with [], but cannot be updated
  since strings are immutable. E.g., src_python[:exports code]{assert 'i' ==
  'hi'[1]}.
  :Hide:
  #+begin_src python
assert 'i' == 'hi'[1]
#+end_src
  :End:

+ src_python[:exports code]{str(x)} returns a (pretty-printed) string
  representation of an object.
:Example:
#+begin_src python
# The string type:
type('a') # â‡’ str
str(12) == '12' # â‡’ True
str(True) # â‡’ 'True'
#+end_src
:End:

** String Comprehensions

String comprehensions are formed by joining all the strings in the resulting
iterable ---we may join using any separator, but the empty string is common.
#+begin_src python
assert '5 â‰¤ 25 â‰¤ 125' == (' â‰¤ '.join(str(5 ** i) for i in [1, 2, 3]))
#+end_src

+ =s.join(xs).split(s) â‰ˆ xs=
+ ~xs.split(s)~     â‡’ split string =xs= into a list every time =s= is encountered
:Example:
#+begin_src python
"!".join(['a', 'bob', 'jim']) # â‡’ a!bob!jim
'a!bob!jim'.split('!') # â‡’ ['a', 'bob', 'jim']

assert ['a', 'bob', 'jim'] == ("!".join(['a', 'bob', 'jim']).split('!'))
#+end_src
:End:

** String methods

Useful string operations:
| ~s.startswith(â‹¯)~ | ~s.endswith(â‹¯)~ |
| ~s.upper()~       | ~s.lower()~     |

+ src_python[:exports code]{ord/chr} to convert between characters and integers.
+ src_python[:exports code]{input(x)} asks user for input with optional prompt ~x~.
+ E.g., src_python[:exports code]{i = int(input("Enter int: "))} â‡’ gets an integer from user

** f-strings: Formatted String Literals

*f-strings* are string literals that have an =f= before the starting quote and may
contain curly braces surrounding expressions that should be replaced by their
values.

#+begin_src python
name, age = "Abbas", 33.1
print(f"{name} is {age:.2f} years {'young' if age > 50 else 'old'}!")
# â‡’ Abbas is 33.10 years old!
#+end_src

F-strings are expressions that are evaluated at runtime, and are generally
faster than traditional formatted strings ---which Python also supports.

The brace syntax is ~{expression:width.precision}~, only the first is
 mandatory and the last is either ~ğ“ƒf~ or ~ğ“ƒe~ to denote ğ“ƒ-many decimal points or
 scientific notation, respectively.

:StringSpecfifiers:
# Strings are formatted using â€œspecfication-string % argumentsâ€:
print("%s is %d years old" % ('James' , 12))

Specifiers:
| %s   | String representation        |
| %d   | Integers                     |
| %f   | floating point numbers       |
| %.ğ“ƒf | floats with ğ“ƒ decimal values |
:End:


# #
#+latex: \vspace{-1em}

* Lists

#+begin_parallel org
#+latex: \hspace{-1.3em}
Python supports zero-indexed heterogeneous lists.

#+latex: \vspace{1em}

#+latex: \hspace{-1.3em}
Like all sequence types, we access values with indices ~xs[0]~ and modify them in
the same way. Above ~xs[12]~ yields an out of range error.

#+latex: \columnbreak
   #+begin_src python
# Making lists
xs = []
xs.append(1)
xs.append([2, 'a'])
xs.append('b')
# or:
xs = [1, [2, 'a'], 'b']
#+end_src
#+end_parallel

#+latex: \vspace{-0.5em}
Besides all of the iterable methods above, for lists we have:

+ src_python[:exports code]{list(cs)}
  â‡’ turns a string/tuple into the list of its characters/components
+ ~xs.remove(x)~ â‡’ remove the first item from the list whose value is ~x~.
+ ~xs.index(x)~ â‡’ get first index where ~x~ occurs, or error if it's not there.
+ ~xs.pop(i)~ â‰ˆ ~(x := xs[i], xs := xs[:i] + xs[i+1:])[0]~
  - [[Named Expressions]] are covered below;
    if ~i~ is omitted, it defaults to ~len(xs)-1~.
  - Lists are thus stacks with interface ~append/pop~.
+ For a list-like container with fast appends and [[https://docs.python.org/3/tutorial/datastructures.html#using-lists-as-queues][pops on either end]], see the
  [[https://docs.python.org/3/library/collections.html#module-collections][deque collection]] type.

:Example:
#+begin_src python
xs = list(range(10))
# x = xs.pop(4)
i = 4
x = (x := xs[i], xs := xs[:i] + xs[i+1:])[0]
print(x, xs)
#+end_src

#+RESULTS:
: 4 [0, 1, 2, 3, 5, 6, 7, 8, 9]

# +RESULTS:
: 4 [0, 1, 2, 3, 5, 6, 7, 8, 9]

:End:

** Negative space :ignore:
# #
#+latex: \vspace{-1em}

* Sets

#+latex: \vspace{-0.5em}
#+begin_parallel org
#+latex: \hspace{-1.3em}
src_python[:exports code]{set(xs)} to transform a sequence into a set, which is a list without repetitions.

#+latex: \vspace{1em}\hspace{-1.3em}
Useful methods ~a.ğ“‚(b)~ where ğ“‚ is =intersection, union, difference, symmetric_difference=.

#+latex: \columnbreak
#+begin_src python
# Two ways to make sets; no duplicates!
assert {1, 2, 3} == set([3, 1, 1, 2])

# Set comprehension
{x for x in 'abracadabra'
   if  x not in 'abc'}
# â‡’ {'d', 'r'}
#+end_src

#+end_parallel

# #
#+latex: \vspace{-1.5em}

* Dictionaries

# +latex: \hspace{-2.3em}
#+latex: \hspace{-1.5em}
Note that ={}= denotes the empty dictionary, not the empty set.

A /dictionary/ is like a list but indexed by user-chosen /keys/, which are members
of any immutable type.  /It's really a set of â€œkey:valueâ€ pairs./

E.g., a dictionary of numbers along with their squares can be written explicitly
(below left) or using a comprehension (below right).
#+begin_src python
assert {2: 4, 4: 16, 6: 36} == {x: x**2 for x in (2, 4, 6)}
#+end_src

** Dictionaries implement hierarchical tree structures and case statements
# A dictionary is like a list but works with key-value pairs instead of numeric
# indices.

# For example, we can use dictionaries to implement hierarchical tree structures.
# ( Classes are dictionaries with nifty ways to â€œmix inâ€ functionality; e.g.,
# inheritance and overloading. )

#
#+begin_parallel org

| *Hierarchical Tree Structures*  |

#+latex:\vspace{0.5em}
  #+begin_src python
you = { "kid1": "Alice"
      , "kid2": { "kid1": "Bobert"
                , "kid2": "Mary"
                }
      }
#+end_src
#+latex: \columnbreak
| *â€œCase Statementsâ€* |

#+latex:\vspace{0.5em}
     #+begin_src python
i, default = 'k' , "Dec"
x = { 'a': "Jan"
    , 'k': "Feb"
    , 'p': "Mar"
    }.get(i, default)
assert x == 'Feb'
    #+end_src
#+end_parallel

#+latex:\vspace{-1em}
Alternatively: Start with =you = {}= then later add key-value pairs: =you[key] = value=.
#+begin_src python
assert 'Bobert' == you["child2"]['child1'] # access via indices
del you['child2']['child2']                # Remove a key and its value
assert 'Mary' not in you['child2'].values()
#+end_src

** Dictionary Methods
#+latex: \vspace{1em}
+ src_python[:exports code]{list(d)} â‡’ list of keys in dictionary ~d~.
+ ~d.keys(), d.values()~ â‡’ get an iterable of the keys or the values.
+ src_python[:exports code]{k in d} â‡’ Check if key ~k~ is in dictionary ~d~.
+ src_python[:exports code]{del d[k]} â‡’ Remove the key-value pair at key ~k~ from dictionary ~d~.
+ ~d[k] = v~ â‡’ Add a new key-value pair to ~d~, or update the value at key ~k~ if
  there is one.
+ src_python[:exports code]{dict(xs)} â‡’ Get a dictionary from a list of key-value tuples.

   When the keys are strings, we can specify pairs using keyword arguments:
   #+latex: \newline
   src_python[:exports code]{dict(me = 12, you = 41, them = 98)}.

   Conversely, ~d.items()~ gives a list of key-value pairs; which is useful
   to have when looping over dictionaries.

In dictionary literals, later values will always override earlier ones:
#+begin_src python
assert dict(x = 2) == {'x':1, 'x':2}
#+end_src

Dictionary update: ~d = {**d, keyâ‚:valueâ‚, â€¦, keyâ‚™:valueâ‚™}~.
# dict.update !

** COMMENT Negative Space :ignore:
#+latex: \vspace{-1em}
* Splicing

#+latex: \hspace{-1.3em}
=xs[start:stop:step]= â‰ˆ the subsequence of =xs= from =start= to =stop-1= skipping
every =step-1= element.  All are optional, with =start, stop=, and =step= defaulting
to =0, len(xs)=, and =1=; respectively.
+ The start is always included and the end always excluded.
+ =start= may be negative: -ğ“ƒ means the ğ“ƒ-th item from the end.
+ All slice operations return a new sequence containing the requested elements.
+ One colon variant: =xs[start:stop]=, both =start= and =stop= being optional.
+ /Slicing applies to sequence types only/ ---i.e., types implementing ~__getitem__~.

# #
#+begin_parallel org
#+begin_src python :session splicing
xs = [11, 22, 33, 44, 55]

assert xs[3:-5]  == []
assert xs[3:7]   == [44, 55]
assert (   xs[3:77]
        == xs[3: min(77, len(xs))]
        == xs[3:5])
#+end_src

#+latex: \columnbreak
#+begin_src python :session splicing
assert "ola"     == "hola"[1:]
assert (3, 2, 1) == (1, 2, 3)[::-1]

assert xs[-1::] == [55]

n, N = 10, len(xs)
assert xs[-n::] == xs[max(0, N - n)::]
   #+end_src
#+end_parallel

# Then:
#+latex: \vspace{-1em}
#
# #
#+begin_parallel org
/Useful functions via splicing/

#+latex: \vspace{1em}
| ~xs[:ğ“ƒ]~  | â‡’ | take first ğ“ƒ items     |
| ~xs[0]~   | â‡’ | head of ~xs~             |
| ~xs[ğ“ƒ:]~  | â‡’ | drop first ğ“ƒ items     |
| ~xs[1:]~  | â‡’ | tail of ~xs~             |
| ~xs[-1]~  | â‡’ | last element of ~xs~     |
| ~xs[::ğ“€]~ | â‡’ | get every ğ“€-th value   |
| ~ğ“ƒ * [x]~   | â‡’ | the list consisting of |
|         |   | ~x~ repeated ğ“ƒ-times     |

#+LATEX: \columnbreak
/Splice laws/
#+latex: \vspace{1em}
| ~xs[:]~           | â‰ˆ | ~xs~           |
| ~xs[::]~          | â‰ˆ | ~xs~           |
| ~xs[0:len(xs)]~   | â‰ˆ | ~xs~           |
| ~xs[::-1]~        | â‰ˆ | ~reversed(xs)~ |
| ~xs[:ğ“ƒ] + xs[ğ“ƒ:]~ | â‰ˆ | ~xs~           |
| ~len(xs[ğ“‚:ğ“ƒ])~    | â‰ˆ | ~ğ“ƒ - ğ“‚~        |

# Assignment to slices is possible, resulting in sequences with possibly different
# sizes.
#+latex: \vspace{2em}
|   | ~xs[ğ“‚:ğ“ƒ] = ys~              |
| â‰¡ | ~xs = xs[:ğ“‚] + ys + xs[ğ“ƒ:]~ |
#+end_parallel

Assignment to slices is possible, resulting in sequences with possibly different
sizes.
# | ~xs[ğ“‚:ğ“ƒ] = ys~ | â‰¡ | ~xs = xs[:ğ“‚] + ys + xs[ğ“ƒ:]~ |
#+begin_src python
xs      = list(range(10)) # â‡’ xs â‰ˆ [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
xs[3:7] = ['a', 'b']      # â‡’ xs â‰ˆ [0, 1, 2, 'a', 'b',   7, 8, 9]
#+end_src
# assert xs == [0, 1, 2, 'a', 'b', 7, 8, 9]

Other operations via splicing:
+ ~0 == s.find(s[::-1])~ â‡’ string ~s~ is a palindrome
+ src_python[:exports code]{inits xs â‰ˆ [xs[0:i] for i in range(1 + len(xs))]}
+ src_python[:exports code]{segs xs â‰ˆ [xs[i:j] for i in range(len(xs)) for j in
  range(i, len(xs))]}

# + The ~[::-1]~, for reversal, above is known as the â€œalien smiley faceâ€.
# Maybe not.

** break Space                                                       :ignore:
# #
#+latex: \columnbreak

* Functions

** Intro :ignore:

#+latex: \hspace{-1.3em}
 /Functions are first-class citizens/: Python has one namespace for functions and
 variables, and so there is no special syntax to pass functions around or to use
 them anywhere, such as storing them in lists.

  + src_python[:exports code]{return} clauses are optional; if there are none, a
    function returns src_python[:exports code]{None}.

  + Function application always requires parentheses, even when there are no
    arguments.

  + Any object ~x~ can be treated like a function, and use the ~x(â‹¯)~ application
    syntax, if it implements the ~__call__~ method: ~x(â‹¯) â‰ˆ x.__call__(â‹¯)~.  The
    src_python[:exports code]{callable} predicate indicates whether an object is
    callable or not.

     # If ~callable(x)~ then ~x(â‹¯)~ is valid syntax;
     # ~callable(x) â‰ˆ assert hasattr(x, '__call__')~

  + Functions, and classes, can be nested without any special syntax; the nested
    functions are just new local values that happen to be functions. Indeed,
    nested functions can be done with src_python[:exports code]{def} or with
    assignment and src_python[:exports code]{lambda}.

  + Functions can receive a variable number of arguments using ~*~.
    # and an implicit
    # hash ---i.e., keyword arguments--- using ~**~.

 #+begin_src python :results output :session compose
def compose(*fs):
    """Given many functions fâ‚€,â€¦,fâ‚™ return a new one: Î» x. fâ‚€(â‹¯(fâ‚™(x))â‹¯)"""
    def seq(x):
        seq.parts = [f.__name__ for f in fs]
        for f in reversed(fs):
            x = f(x)
        return x
    return seq

print (help(compose))  # â‡’ Shows the docstring with function type
compose.__doc__ = "Dynamically changing docstrings!"

# Apply the â€œcomposeâ€ function;
# first define two argument functions in two ways.

g = lambda x: x + 1
def f(x): print(x)

h = compose(f, g, int)
h('3')                         # â‡’ Prints 4
print(h.parts)                 # â‡’ ['f', '<lambda>', 'int']
print (h.__code__.co_argcount) # â‡’ 1; h takes 1 argument!

# Redefine â€œfâ€ from being a function to being an integer.
f = 3
# f(1) # â‡’ Error: â€œfâ€ is not a function anymore!
#+end_src

#+RESULTS:
: Help on function compose in module __main__:
:
: compose(*fs)
:     Given fâ‚€,â€¦,fâ‚™ return Î» x â†¦ fâ‚€(â‹¯(fâ‚™(x))â‹¯)
:
: None
: 4
: ['f', '<lambda>', 'int']
: 1

Note that ~compose()~ is just the identity function ~lambda xâˆ¶ x~.

** Functions have attributes

The first statement of a function body can optionally be a â€˜docstringâ€™, a string
enclosed in three double quotes.  You can easily query such documentation with
~help(functionName)~. In particular, ~f.__code__.co_argcount~ to obtain the number
of arguments ~f~ accepts.

That [[https://www.python.org/dev/peps/pep-0232/][functions have attributes]] ---state that could alter their behaviour---
is not at all unexpected: Functions are objects; Python objects have
attributes like ~__doc__~ and can have arbitrary attributes (dynamically) attached
to them.

** COMMENT ~__code__~
Use ~print(help(f.__code__))~ to see code-related attributes, such as:

 | ~co_argcount~ | Number of function arguments              |
 | ~co_consts~   | Constant appearing in the function        |
 | ~co_filename~ | Name of parent file                       |
 | ~co_varnames~ | The variable names used in the definition |

** On the nature of Î»

A src_python[:exports code]{lambda} is a single line expression; you are
 prohibited from writing statements like src_python[:exports code]{return},
 but the semantics is to do the src_python[:exports code]{return}.

src_python[:exports code]{lambda args: (xâ‚€ := eâ‚€, â€¦, xâ‚™ := eâ‚™)[k]} is a way to
 perform ~n~-many stateful operations and return the value of the ~k~-th one. See
 ~pop~ above for lists; [[Named Expressions]] are covered below.
 # This is similar to prog1, prog2, and progn in lisp.

 For fresh name ~x~, a *let-clause* /â€œlet x = e in â‹¯â€/ can be simulated with ~x = e;
 â€¦; del x~.  However, in combination with [[Named Expressions]], lambda's ensure a
 new local name: src_python[:exports code]{(lambda x = e: â‹¯)()}.

:StatefulExample:
 #+begin_src python
def f():
    f.ran += 1
    return 'bye'

f.ran = 0

f(), f(), f()
assert 'ran' in dir(f) and 3 == f.ran
 #+end_src
:End:

** Default & keyword argument values
      #+latex: \vspace{0.7em}
      | *Default & keyword argument values are possible* |

 # +latex: \vspace{-0.5em}
   #+begin_src python :session kwds
def go(a, b=1, c='two'):
    """Required 'a', optional 'b' and 'c'"""
    print(a, b, c)
#+end_src
Keyword arguments must follow positional arguments; order of keyword arguments
(even required ones) is not important.
  - Keywords cannot be repeated.
#+begin_src python :session kwds
go('a')          # â‡’ a 1 two ;; only required, positional
go(a='a')        # â‡’ a 1 two ;; only required, keyword
go('a', c='c')   # â‡’ a 1 c   ;; out of order, keyword based
go('a', 'b')     # â‡’ a b two ;; positional based
go(c='c', a='a') # â‡’ a 1 c   ;; very out of order
   #+end_src

** Dictionary arguments
      #+latex: \vspace{0.7em}
      | *Dictionary arguments* |

 # +latex: \vspace{-0.5em}
After the /required/ positional arguments, we can have an arbitrary number of
optional/ positional arguments (a tuple) with the syntax ~*args~, after that we
may have an arbitrary number of /optional/ keyword-arguments (a dictionary) with
the syntax ~**args~.

The reverse situation is when arguments are already in a list or tuple but need
to be unpacked for a function call requiring separate positional
arguments. Recall, from above, that we do so using the ~*~ operator; likewise ~**~
is used to unpack dictionaries.
+ E.g., if =f= needs 3 arguments, then =f(*[xâ‚, xâ‚‚, xâ‚ƒ]) â‰ˆ f(xâ‚, xâ‚‚, xâ‚ƒ)=.
  :ConcreteExample:
 #+begin_src python
args = [0, 5]
print (list(range(*args))) # â‡’ [0, 1, 2, 3, 4]
   #+end_src
:End:

#+begin_src python
def go(a, *more, this='âˆ', **kwds):
    print (a)
    for m in more: print(m)
    print (this)
    for k in kwds: print(f'{k} â†¦ {kwds[k]}')
    return kwds['neato'] if 'neato' in kwds else -1

# Elementary usage
go(0)                            # â‡’ 0 âˆ
go(0, 1, 2, 3)                   # â‡’ 0 1 2 3 âˆ
go(0, 1, 2, this = 8, three = 3) # â‡’ 0 1 2 8 three â†¦ 3
go(0, 1, 2, three=3, four = 4)   # â‡’ 0 1 2 âˆ three â†¦ 3 four â†¦ 4

# Using â€œ**â€
args = {'three': 3, 'four': 4}
go(0, 1, 2, **args) # â‡’ 0 1 2 âˆ three â†¦ 3 four â†¦ 4

# Making use of a return value
assert 5 == go (0, neato = 5)
   #+end_src

:Hide:
We may indicate that some arguments are positional only (=a, b=), others are
keyword only (=e, f=), and some may be positional or keyword (=c, d)= with the
syntax: ~def go(a, b, /, c, d, *, e , f)~.
:End:

** Type Annotations
     #+latex: \vspace{1em}
     | *Type Annotations* |

We can [[https://www.python.org/dev/peps/pep-3107/][annotate functions]] by expressions ---these are essentially useful
comments, and not enforced at all--- e.g., to provide [[https://www.python.org/dev/peps/pep-0484/][type hints]].
They're useful to document to human readers
the intended types, or used by third-party tools.
#+begin_src python
# A function taking two ints and returning a bool
def f(x:int, y : str = 'neat') -> bool:
    return str(x) # Clearly not enforced!

print (f('hi')) # â‡’ hi; Typing clearly not enforced

print(f.__annotations__) # â‡’ Dictionary of annotations
#+end_src

** Currying

*Currying*: Fixing some arguments ahead of time.
#
#+begin_parallel org
# To partially apply a function ~f~ with values ~váµ¢~, use ~partial(f, vâ‚€, â€¦, vâ‚™)~.
#+latex: \vspace{0em}
#+begin_src python
   partial(f, vâ‚€, â€¦, vâ‚™)
â‰ˆ lambda xâ‚€, â€¦, xâ‚˜:
    f(vâ‚€, â€¦, vâ‚™, xâ‚€, â€¦, xâ‚˜)
#+end_src

#+latex: \columnbreak
#+begin_src python
from functools import partial

multiply  = lambda x, y, z: z * y + x
twice     = partial(multiply, 0, 2)
assert 10 == twice(5)
#+end_src

#+RESULTS:

#+end_parallel

Using decorators and classes, we can make an â€˜improvedâ€™ partial application
mechanism ---see the final page.

** Decorators

#
#+begin_parallel org
*Decorators* allow us to modify functions in orthogonal ways, such as printing
values when debugging, without messing with the core logic of the function.
#+latex: \vspace{1em}
E.g., to do preprocessing before and after a function call ---e.g., =typed= below for
this standard template.
#+latex: \vspace{1em}
Decorators are just functions that alter functions, and so they can return
anything such as an integer thereby transforming a function name into an integer
variable.
#+LATEX: \ifnum\cheatsheetcols=1 \columnbreak \else \columnbreak \fi
#+begin_src python
@decorator_2
@decorator_1
def fun(args):
    â‹¯

â‰ˆ

def fun(args):
    â‹¯
fun = decorator_2(decorator_1(fun))
#+end_src

#+latex: \vspace{1em}
The [[https://www.python.org/dev/peps/pep-0318/#current-syntax][decoration syntax]] ~@ d f~ is a convenient syntax that emphasises
code acting on code.

#+end_parallel

:Example_repetition_decorator:
#+begin_src python
def doit(howmany):
    # Repeat a function â€œhowmanyâ€ times
    def doit_decorator(fun):
        def repeated(*args, **kwds):
            for _ in range(howmany):
                fun(*args, **kwds)
        return repeated
    return doit_decorator

@doit(4)
def greeting(name):
    print('Hello, ' + name)

greeting('james') # â‡’ prints 4 times
#+end_src
:End:

Decorators can be helpful for functions we did not write, but we wish to [[https://en.wikipedia.org/wiki/Advice_(programming)][advise]]
their behaviour; e.g., ~math.factorial = my_decorator(math.factorial)~ to make
the standard library's ~factorial~ work in new ways.

When decorating, we may use [[https://stackoverflow.com/a/36908/3550444][*args and **kwargs]] in the inner wrapper function so
that it will accept an arbitrary number of positional and keyword arguments. See
=typed= below, whose inner function accepts any number of arguments and passes
them on to the function it decorates.

We can also use decorators to add a bit of type checking at runtime:
#+begin_src python :session learning
import functools

# â€œtypedâ€ makes decorators; â€œtyped(sâ‚, â€¦, sâ‚™, t)â€ is an actual decorator.
def typed(*types):
    ,*inTys, outT = types
    def decorator(fun):
        @functools.wraps(fun)
        def new(*args, **kwdargs):
            # (1) Preprocessing stage
            if any(type(ğ“Œ := arg) != ty for (arg, ty) in zip(args, inTys)):
                nom = fun.__name__
                raise TypeError (f"{nom}: Wrong input type for {ğ“Œ!r}.")
            # (2) Call original function
            result = fun(*args, **kwdargs) # Not checking keyword args
            # (3) Postprocessing stage
            if type(result) != outT:
                raise TypeError ("Wrong output type!")
            return result
        return new
    return decorator
#+end_src

#+RESULTS:

After being decorated, function attributes such as ~__name__~ and ~__doc__~ refer to
the decorator's resulting function. In order to have it's attributes preserved,
we copy them over using [[https://docs.python.org/3/library/functools.html#functools.wraps][ ~@functools.wraps~ decorator]] ---or by declaring
~functools.update_wrapper(newFun, oldFun)~.

#+begin_src python :session learning
# doit : str Ã— list Ã— bool â†’ NoneType
@typed(str, list, bool, type(None))
def doit(x, y, z = False, *more):
    print ((ord(x) + sum(y)) * z, *more)
#+end_src
Notice we only typecheck as many positions as given, and the output; other
arguments are not typechecked.
#+begin_src python :session learning
# â‡’ TypeError: doit: Wrong input type for 'bye'!
doit('a', [1, 2], 'bye')

# â‡’ 100 n i ;; typechecking succeeds
doit('a', [1, 2], True, 'n', 'i')

# â‡’ 0; Works with defaults too ;-)
doit(x, y)

# â‡’ 194; Backdoor: No typechecking on keyword arguments!
doit('a', z = 2, y = {})

  #+end_src
# print(help(doit))
# â‡’ It would say â€œtyped.newâ€, from above!
# To avoid this, we use the functools.wraps decorator.

The implementation above matches the ~typed~ specification, but the one below does
not and so always crashes.
#
# +begin_parallel org
#+begin_src python :session learning
# This always crashes since
# the result is not a string.
@typed(int, str)
def always_crashes(x):
    return 2 + x
#+end_src
# +end_parallel

Note that ~typed~ could instead /enforce/ type annotations, as shown before, at run
time ;-)

An easier way to define a family of decorators is to define a
[[https://github.com/micheles/decorator][decorator-making-decorator]]!

** Negative Space :ignore:
# #
#+latex: \vspace{-1em}
* Object-Oriented Programming

#+latex: \hspace{-1.3em}
  /Classes/ bundle up data and functions into a single entity; /Objects/ are just
  values, or /instances/, of class types. That is, a class is a record-type
  and an object is a tuple value.

1. A Python /object/ is just like a real-world object: It's an
   entity which has attributes ---/a thing which has features/.

2. We /classify/ objects according to the features they share.

3. A /class/ specifies properties and behaviour, an implementation of
   which is called an /object/. Think class is a cookie cutter, and
   an actual cookie is an object.

4. Classes are also known as â€œbundled up dataâ€, structures, and records.

   They let us treat a collection of data, including methods,
   as one semantic entity. E.g., rather than speak of
   name-age-address tuples, we might call them person objects.

   Rather than â€œacting onâ€ tuples of data, an object
   â€œknows how to actâ€; we shift from ~doit(xâ‚, â€¦, xâ‚™)~
   to ~ğ“.doit()~.
   We /abstract away/ the =n=-many details into 1 self-contained idea.
   # Rather than worry about =n= things, we worry about 1 instead.

** Person: Empty Class
#+latex: \vspace{0.5em}
   | *What can we learn from an empty class?* |

#+begin_parallel org
#+begin_src python :session empty-person
class Person:
    """An example, empty, class."""
    pass
#+end_src

#+latex: \vspace{1em}
src_python[:exports code]{pass} is the â€œdo nothingâ€ statement. It's useful for
writing empty functions/classes that will be filled in later or for explicitly
indicating do-nothing cases in complex conditionals.

#+latex: \vspace{0.5em}\hrule\vspace{0.5em}
#+begin_src python :session empty-person
# We defined a new type!
assert isinstance(Person, type)

# View information of the class
print (help(Person))
# Or use: Person.__name__,
# Person.__doc__, Person.__dict__

# Let's make a Person object
jasim = Person()
assert Person == type(jasim)
assert isinstance(jasim, Person)
#+end_src

#+latex: \vfill\hrule\vspace{0.5em}
Instance (reference) equality is compared with src_python[:exports code]{is}.
#+latex: \vspace{0.3em}
#+begin_center python
src_python[:exports code]{x is y â‰¡ id(x) == id(y)}
#+end_center
~id(x)~ is a unique number identifying object ~x~; usually its address in memory.
#+latex: \vspace{0.5em}
#+begin_src python :session empty-person
jason = jasim
qasim = Person ()
assert jason is jasim and jasim is jason
assert qasim is not jasim
#+end_src

#+latex: \vspace{0.5em}\hrule\vspace{0.5em}
#+begin_src python :session empty-person
# Check attributes exist before use
assert not hasattr(jasim, 'work')

# Dynamically add new (instance) attributes
jasim.work = 'farmer'
jasim.nick = 'jay'

# Delete a property
del jasim.nick

# View all attribute-values of an object
print(jasim.__dict__) # {'work': 'farmer'}
#+end_src
#+latex: \vspace{0.7em}\hrule\vspace{0.5em}
#+end_parallel

| /Look at that, classes are just fancy dictionary types!/ |
The converse is also true: src_python[:exports code]{class X: a = 1   â‰ˆ   X = type('X', (object,), dict(a = 1))}
** COMMENT Dictionaries and Classes                                          :ignore:

Objects are like dictionaries, but classes allow us to â€œmix inâ€ functionality
using inheritance and (dynamically added) attributes. Just as we could get
dictionaries from classes, we can conversely obtain classes from dictionaries.

One can create classes dynamically by making new type objects; e.g.,
#+begin_center python
src_python[:exports code]{class X: a = 1  â‰¡  X = type('X', (object,), dict(a = 1))}
#+end_center
We passed in the name of the new class, along with the tuple of parent classes,
and finally the dictionary of attribute-value pairs.

** A More Complex ~Person~ Class

#+latex: \vspace{0.5em}
| *Let's add more features!* |

src_python[:exports code]{# [0]} An =__init__= method is called whenever a new
object is created via =Person(name, age)=. It /constructs/ the object by
/initialising/ its necessary features.

src_python[:exports code]{# [1]} The argument src_python[:exports code]{self}
refers to the object instance being created and src_python[:exports code]{self.x
= y} is the creation of an attribute =x= with value =y= for the newly created object
instance. Compare src_python[:exports code]{self} with =jasim= above and
src_python[:exports code]{self.work} with =jasim.work=. It is convention to use
the name src_python[:exports code]{self} to refer to the current instance, you
can use whatever you want but it must be the first argument.

src_python[:exports code]{# [2]} Each =Person= instance has their own =name= and
=work= features, but they universally share the =Person.__world= feature.
Attributes starting with two underscores are /private/; they can only be altered
within the definition of the class.  Names starting with no underscores are
/public/ and can be accessed and altered using dot-notation. Names starting with
one underscore are /protected/; they can only be used and altered by children
classes.

#+begin_src python :session OOP
class Person:
    __world = 0  # [2]

    def __init__(self, name, work): # [0]
        self.name = name
        self.work = work
        Person.__world += 1

    def speak(me): # [1] Note, not using â€œselfâ€
        print (f"I, {me.name}, have the world at my feet!")

    # Implementing __str__ allows our class to be coerced as string
    # and, in particular, to be printed.
    def __str__(self):
        return (f"In a world of {Person.__world} people, "
                f"{self.name} works at {self.work}")

    # [3] Any class implementing methods __eq__ or __lt__
    # can use syntactic sugar == or <, respectively.
    def __eq__(self, other):
        return self.work == other.work

    # We can loop over this class by defining __iter__,
    # to setup iteration, and __next__ to obtain subsequent elements.
    def __iter__(self):
        self.x = -1
        return self

    def __next__(self):
        self.x += 1
        if self.x < len(self.name): return self.name[self.x]
        else: raise StopIteration
#+end_src

#+RESULTS:

** Making People
        #+latex: \vspace{1em}
  | *Making People* |

#+begin_src python :session OOP
jason = Person('Jasim', "the old farm")
kathy = Person('Kalthum', "Jasim's farm")
print(kathy) # â‡’ In a world of 2 people, Kalthum works at Jasim's farm
# Two ways to use instance methods
jason.speak()       # â‡’ I, Jasim, have the world at my feet!
Person.speak(jason)
#+end_src

The following code /creates a new public feature that happens to have the same
name as the private one/.  This has no influence on the private feature of the
same name!  @@latex: \newline @@ See src_python[:exports code]{# [2]} above.
#+begin_src python :session OOP
Person.__world = -10
# Check that our world still has two people:
print(jason) # â‡’ In a world of 2 people, Jasim works at the old farm
#+end_src
# +latex: \vspace{0.5em}\hrule\vspace{0.5em}

** Syntax Overloading: Dunder Methods

        #+latex: \vspace{1em}
  | *Syntax Overloading: Dunder Methods* |

src_python[:exports code]{# [3]} Even though =jasim= and =kathy= are distinct
people, in a dystopian world where people are unique up to contribution, they
are considered â€œthe sameâ€.
#+begin_src python :session OOP
kathy.work = "the old farm"
assert jason is not kathy
assert jason == kathy
#+end_src

 We can use any Python syntactic construct for new types by implementing the
 dunder ---â€œdâ€ouble â€œunderâ€score--- methods that they invoke. This way new types
 become indistinguishable from built-in types. E.g., implementing ~__call__~ makes
 an object behave like a function whereas implementing ~__iter__~ and ~__next__~
 make it iterable ---possibly also implementing ~__getitem__~ to use the slicing
 syntax ~obj[start:stop]~ to get a â€˜subsegmentâ€™ of an instance.  Implementing
 ~__eq__~ and ~__lt__~ lets us use ~==, <~ which are enough to get ~<=, >~ if we
 decorate the class by the [[https://docs.python.org/2/library/functools.html#functools.total_ordering][ ~@functools.total_ordering~ decorator]].  [[https://docs.python.org/3/reference/datamodel.html#object.__rsub__][Reflected
 operators]] ~__râ„´ğ“…__~ are used for arguments of different types: @@latex:
 \newline@@ ~x âŠ• y â‰ˆ y.__râŠ•__(x)~ if ~x.__âŠ•__(y)~ is not implemented.

#+begin_src python :session OOP
# Loop over the â€œjasonâ€ object; which just loops over the name's letters.
for e in jason:
    print (e)  # â‡’ J \n a \n s \n i \n m

# Other iterable methods all apply.
print(list(enumerate(jason)) # â‡’ [(0, 'J'), (1, 'a'), (2, 's'), â€¦]
#+end_src
# +latex: \vspace{0.5em}\hrule\vspace{0.5em}

 One should not have attributes named such as ~__attribute__~; the dunder naming
 convention is for the Python implementation team.

 - [[https://rszalski.github.io/magicmethods/][Here]] is a list of possible dunder methods.
 -  ~__add__~ so we can use ~+~ to merge instances ---then use ~sum~ to â€˜addâ€™ a list of
   elements.
 - Note: ~ğ’½(x) â‰ˆ x.__ğ’½__~ for ğ’½: src_python[:exports code]{len, iter, next, bool,
   str}.

** Extension Methods
        #+latex: \vspace{0.5em}
  | *Extension Methods* |

        #+latex: \vspace{-0.5em}
#+begin_src python :session OOP
# â€œspeakâ€ is a public name, so we can assign to it:
# (1) Alter it for â€œjasonâ€ only
jason.speak =  lambda: print(f"{jason.name}: Hola!")
# (2) Alter it for ALL Person instances
Person.speak = lambda p: print(f"{p.name}: Salam!")
jason.speak() # â‡’ Jasim: Hola!
kathy.speak() # â‡’ Kalthum: Salam!
#+end_src

Notice how =speak()= above was altered. In general, we can â€œmix-in new
methodsâ€ either at the class level or at the instance level in the same
way.
#
#+begin_parallel org
#+BEGIN_SRC python
# New complex method
def speak(self):
    â‹¯

# Add it at the class level
Person.speak = speak

# Remove â€œspeakâ€ from
# the current scope
del speak
#+END_SRC
#+latex: \columnbreak
This ability to extend classes with new functions does not work with the builtin
types like src_python[:exports code]{str} and src_python[:exports code]{int};
neither at the class level nor at the instance level. If we want to inject
functionality, we can simply make an empty class like the first incarnation of
~Person~ above. An example, ~PartiallyAppliedFunction~, for altering how function
calls work is shown on the right column â‡’
#+end_parallel

** Inheritance
        #+latex: \vspace{1em}
        | *Inheritance* |

A class may /inherit/ the features of another class; this is essentially
automatic copy-pasting of code. This gives rise to /polymorphism/,
the ability to â€œuse the same function on different objectsâ€:
If class ~A~ has method ~f()~, and classes ~B~ and ~C~ are children of ~A~,
then we can call ~f~ on ~B~- and on ~C~-instances; moreover ~B~ and ~C~ might
redefine ~f~, thereby â€˜overloadingâ€™ the name, to specialise it further.
# + For example, recall that lists and dictionaries inherit from iterables ;-)

#+begin_src python :session OOP
class Teacher(Person):
    # Overriding the inherited __init__ method.
    def __init__(self, name, subject):
        super().__init__(name, f'the university teaching {subject}')
        self.subject = subject

assert isinstance(Teacher, type)
assert issubclass(Teacher, Person)
assert issubclass(Person, object)
# The greatest-grandparent of all classes is called â€œobjectâ€.

moe = Teacher('Ali', 'Logic')
assert isinstance(moe, Teacher) # By construction.
assert isinstance(moe, Person)  # By inheritance.
print(moe)
# â‡’ In a world of 3 people, Ali works at the university teaching Logic
   #+end_src

# #
# +latex: \vspace{-1.5em}

* COMMENT abstractmethod
#+begin_src python
from abc import ABC, abstractmethod

class A(ABC):
    @abstractmethod
    def doit(self):
        pass

class B(A):
    def doit(self):
        return "â„¬ nice"

class C(A):
    def doit(self):
        return "ğ’ nice"

# a = A() # â‡’ â€œAâ€ has an abstract method, so cannot make values of this type.
b = B()
c = C()
print (b.doit(), c.doit())
#+end_src

#+RESULTS:
: â„¬ nice ğ’ nice

* Decorators and Classes

 Since ~@C f~ stands for ~f = C(f)~, we can decorate via /classes/ ~C~ whose ~__init__~
 method takes a function. Then ~@C f~ will be a class!  If the class implements
 ~__call__~ then we can continue to treat ~@C f~ as if it were a (stateful)
 function.

 In turn, we can also decorate class methods in the usual way.  E.g., when a
 method =ğ“(self)= is decorated [[https://docs.python.org/library/functions.html#property][ ~@property~ ]], we may attach logic to its setter
 ~obj.ğ“ = â‹¯~ and to its getter ~obj.ğ“~!

 We can decorate an entire class ~C~ as usual; =@dec C= still behaves as update via
 function application: =C = dec(C)=. This is one way to change the definition of a
 class dynamically.
 + E.g., to implement design patterns like the singleton pattern.

 A class decorator is a function from classes to classes; if we apply a function
 decorator, then only the class' constructor is decorated ---which makes sense,
 since the constructor and class share the same name.

** Curry Decorator

#+LATEX: \ifnum\cheatsheetcols=1 \else \columnbreak \vspace{-1em} \fi
| *Example: Currying via Class Decoration* |

#+latex: \vspace{-0.5em}
Goal: We want to apply functions in many ways, such as ~f(xâ‚, â€¦, xâ‚™)~
and ~f(xâ‚, â€¦, xáµ¢)(xáµ¢â‚Šâ‚, â€¦, xâ‚™)~; i.e., all the calls on the right below
are equivalent.
#+latex: \vspace{-0.5em}
# #
#+begin_parallel org
#+begin_src python :session curry
@curry
def doit(x, y, z):
    print('got', x, y, z)
#+end_src
#+latex: \columnbreak
#+begin_src python :session curry
doit(1)(2)(3)
doit(1, 2)(3)
doit(1)(2, 3)
doit(1, 2, 3)
doit(1, 2, 3, 666, 'âˆ') # Ignore extra args
 #+end_src
#+end_parallel

#+latex: \vspace{-1.5em}
The simplest thing to do is to transform src_python[:exports code]{f = lambda
xâ‚, â€¦, xâ‚™: body} into src_python[:exports code]{nestLambdas(f, [],
f.__code__.co_argcount) = lambda xâ‚: â€¦: lambda xâ‚™: body}.
#+begin_src python :session curry
def nestLambdas (func, args, remaining):
   if remaining == 0: return func(*args)
   else: return lambda x: nestLambdas(func, args + [x], remaining - 1)
#+end_src

#+RESULTS:

#+latex: \vspace{-0.5em}
# which is ~lambda xâ‚–â‚Šâ‚: â€¦: lambda xâ‚™: f(vâ‚, â€¦, vâ‚–, xâ‚–â‚Šâ‚, â€¦, xâ‚™)~.
However, the calls shift from ~f(vâ‚, â€¦, vâ‚–)~ to ~f(vâ‚)(vâ‚‚)â‹¯(vâ‚–)~; so we need to
change what it means to call a function.
As already mentioned, we cannot extend built-in classes,
so we'll make a wrapper to slightly alter what it means to
call a function on a smaller than necessary amount of arguments.

#+latex: \vspace{-0.5em}
#+begin_src python :session curry
class PartiallyAppliedFunction():

    def __init__(self, func):
        self.value = nestLambdas(func, [], func.__code__.co_argcount)

    def __mul__ (self, other):
        return PartiallyAppliedFunction(lambda x: self(other(x)))

    apply = lambda self, other: other * self if callable(other) else self(other)
    def __rshift__(self, other):  return self.apply(other)
    def __rrshift__(self, other): return self.apply(other)

    def __call__(self, *args):
        value = self.value
        for a in args:
            if callable(value):
                value = value(a)
        return PartiallyAppliedFunction(value) if (callable(value)) else value

curry = PartiallyAppliedFunction   # Shorter convenience name
#+end_src

#+RESULTS:

The above invocation styles, for ~doit~, now all work ^_^

# Exercise: ~curry~ does not work well with default values; why not? Fix it!
# This' due to co_argcount; we need to take into account the number of keyword
# arguments.
#
# â‡’ Currying is not a big issue, since we have access to * and default
# arguments. â‡
#
# +latex: \newpage
Multiplication now denotes function composition and the [[https://docs.python.org/3/reference/datamodel.html#object.__rsub__][(â€˜râ€™eflected)
â€˜râ€™ight-shift]] denotes forward-composition/application:
| ~(g * f(vâ‚, â€¦, vâ‚˜))(xâ‚, â€¦, xâ‚™) = g(f (vâ‚, â€¦, vâ‚˜, xâ‚))(xâ‚‚, â€¦, xâ‚™)~ |
#+latex: \vspace{-0.5em}
# #
#+begin_parallel org
#+begin_src python :session curry
@curry
def f(x, y, z): return x + y + z

@curry
def g(x, y): return [x] * y
#+end_src

#+RESULTS:

#+latex: \columnbreak
#+begin_src python :session curry
assert(   (g * f(3, 1))(9, 4)
       == (f(3, 1) >> g)(9, 4)
       == [13, 13, 13, 13])

assert (   ['a', 'a', 'b']
        == 2 >> g('a')
             >> curry(lambda x: x + ['b']))
#+end_src

#+RESULTS:

#+end_parallel

#
# partial(f, *vs) = lambda xs: f(*(vs + xs))

* Named Expressions

The value of a [[https://www.python.org/dev/peps/pep-0572/][â€œwalrusâ€]] expression ~x := e~ is the value of ~e~, but it also
introduces the name ~x~ into scope. The name =x= must be an atomic identifier; e.g.,
not an unpacked pattern or indexing; moreover =x= cannot be a ~for~-bound name.

#+begin_parallel org
*â€œsubexpression reuseâ€*
# For complex expression e,
   #+BEGIN_SRC python
      f(e, e)
   â‰ˆ f(x := e, x)
#+END_SRC

#+latex: \vspace{1em}
*â€œif-letâ€*
#+latex: \vspace{0.5em}
  #+BEGIN_SRC python
   x = e; if p(x): f(x)
â‰ˆ if p(x := e): f(x)
#+END_SRC

#+latex: \vspace{0.5em}
  This can be useful to capture the value of a /truthy/ item
  so as to use it in the body:
#+latex: \vspace{0.5em}
  #+BEGIN_SRC python
  if e: x = e; f(x)
â‰ˆ if (x := e): f(x)
#+END_SRC

#+latex: \vspace{0.5em}
*â€œwhile-letâ€*
#+latex: \vspace{0.5em}
  #+BEGIN_SRC python
  while True:
      x = input(); if p(x): break; f(x)
â‰ˆ
  while p(x := input()): f(x)
#+END_SRC

#+latex: \vspace{1em}
*â€œwitness/counterexample captureâ€*
#+latex: \vspace{0.5em}
    #+BEGIN_SRC python
if any(p(witness := x) for x in xs):
    print(f"{witness} satisfies p")

if not all(p(witness := x) for x in xs):
    print(f"{witness} falsifies p")
#+END_SRC
#+end_parallel

#+latex: \vspace{-1em}
*â€œStateful Comprehensionsâ€*
  #+BEGIN_SRC python
   partial sums of xs
â‰ˆ [sum(xs[: i + 1]) for i in range(len(xs))]
â‰ˆ (total := 0, [total := total + x for x in xs])[1]
#+END_SRC

Walrus introduces new names, what if we wanted to check if a name already exists?
 #+begin_src python
# alter x if it's defined else, use 7 as default value
x = x + 2 if 'x' in vars() else 7
#+end_src

:More:
#+begin_src python
vars()['x'] = vars().get('x', 7)

try: x
except NameError: y = 'n'
else: y = x
 #+end_src
:End:

#+latex: \vspace{-1em}

* Vspace :ignore:
#+LATEX: \ifnum\cheatsheetcols=1 \else \vfill \fi
* Modules

#+latex: \hspace{-1.3em}
â‡’ Each Python file ~myfile.py~ determines a module whose contents can be used in
other files, which declare src_python[:exports code]{import myfile}, in the form ~myfile.component~.

â‡’ To use a function ~f~ from ~myfile~ without qualifying it each time, we may use the
~from~ import declaration: src_python[:exports code]{from myfile import f}.

â‡’ Moreover, src_python[:exports code]{from myfile import *} brings into scope
all contents of ~myfile~ and so no qualification is necessary.

â‡’ To use a smaller qualifier, or have conditional imports that alias the imported
modules with the same qualifier, we may use src_python[:exports code]{import thefile as newNameHere}.

:Extending_module_load_path:

Python looks in the current directory by default, but the environment variable
PYTHONPATH specifies additional directories to look for modules in.

Another method is the sys.path.append function. You may execute it before
running an import command:

sys.path.append("/directory_to_be_considered")
:End:

â‡’ A Python package is a directory of files ---i.e., Python modules--- with
a (possibly empty) file named ~__init__.py~ to declare the directory as a package.

â‡’ If ~P~ is a package and ~M~ is a module in it, then we can use src_python[:exports
code]{import P.M} or src_python[:exports code]{from P import M}, with the same
behaviour as for modules. The init file can mark some modules as private and not
for use by other packages.

# #
#+latex: \vspace{-0.5em}

* Column break :ignore:
#+LATEX: \ifnum\cheatsheetcols=1 \else \columnbreak \fi

* Vspace :ignore:
#+LATEX: \ifnum\cheatsheetcols=1 \else \vfill \fi
* Reads
  + [[https://dbader.org/][Dan Bader's Python Tutorials]] ---bite-sized lessons
   - Likewise: [[https://www.w3schools.com/python/python_intro.asp][w3schools Python Tutorial]]
  + [[https://www.learnpython.org/][www.learnpython.org]]
    ---an interactive and tremendously accessible tutorial
  + [[https://docs.python.org/3/tutorial/index.html][The Python Tutorial]]
    ---really good introduction from [[https://www.python.org/][python.org]]
    # I've made it to Â§6
  + https://realpython.com/
    ---real-world Python tutorials
  + [[https://norvig.com/python-lisp.html][Python for Lisp Programmers]]
    # Python is not a Lisp: Lisps !elegantly! treat code as data, which is
    # difficult in Python.
  + [[https://github.com/jupyter/jupyter/wiki/A-gallery-of-interesting-Jupyter-Notebooks][A gallery of interesting Jupyter Notebooks]]
    ---interactive, â€˜liveâ€™, Python tutorials
  + [[https://runestone.academy/runestone/books/published/thinkcspy/index.html][How to think like a computer scientist]]
    ---Python tutorial that covers turtle graphics
    as well as drag-and-drop interactive coding and
    interactive quizzes along the way to check your understanding;
    there are also videos too!
  + [[https://github.com/dbrattli/OSlash][Monads in Python]] ---Colourful Python [[https://github.com/dbrattli/OSlash#tutorials][tutorials]] converted from Haskell
  + [[http://norvig.com/21-days.html][Teach Yourself Programming in Ten Years]]

* COMMENT Nonessential functions

https://docs.python.org/2/library/functions.html#apply

* COMMENT Making ~README.org~

  Evaluate the following source block with ~C-c C-c~
  to produce a ~README~ file.

  # :'( For some reason using {{{title}}} below would not work.

#+NAME: make-readme
#+BEGIN_SRC emacs-lisp
(with-temp-buffer
    (insert
    "#+EXPORT_FILE_NAME: README.org
     # HTML: <h1> PythonCheatSheet </h1>
     ,#+OPTIONS: toc:nil d:nil
     # Toc is displayed below at a strategic position.

     {{{blurb}}}

     :Hide:
     This project is to contain a listing of common results in X Theory.

     ,*The repo contains other articles I've written on X Theory;*
     ,*which may be read in a blog-format at:*
     https://alhassy.github.io/blog/categories/#Xtheory
     :End:

    ,*The listing sheet, as PDF, can be found
     [[https://alhassy.github.io/PythonCheatSheet/CheatSheet.pdf][here]]*,
     or as a [[https://alhassy.github.io/PythonCheatSheet/CheatSheet_Portrait.pdf][single column portrait]],
     while below is an unruly html rendition.

     # Markdown links: [title](target)

     This reference sheet is built from a
     [[https://github.com/alhassy/CheatSheet][CheatSheets with Org-mode]]
     system.

     ,#+TOC: headlines 2
     ,#+INCLUDE: CheatSheet.org
    ")

    ;; No code execution on export
    ;; âŸª For a particular block, we use â€œ:eval never-exportâ€ âŸ«
    ;;
    (let ((org-export-use-babel nil))
      (org-mode)
      ; (org-md-export-to-markdown)
      ; (package-install 'toc-org)
      (toc-org-mode)
      (toc-org-insert-toc)
      (org-org-export-to-org)
      )
)
#+END_SRC

#+RESULTS: make-readme

Note that the ~blurb~ macro is defined by the user, to provide a terse description of the project.
   - Think the one-line statement at the top of a github repo page.

#    The ~d:nil~ ensures the â€˜drawerâ€™ ~:Hide: â‹¯ :End:~ is not exported; it's there for me
#    as a reminder.
